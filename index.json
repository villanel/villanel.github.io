[{"content":"三、线性搜索 3.1什么是线性搜索？ 3.1.1线性搜索的概念 xk+1=xk+αkdkαk：步长因子 dk：搜索方向 则下一步的位置设为φ(α)=f(xk+αkdk)\n从xk出发沿dk方向搜索，确定步长因子αk使得φ(α)\u0026lt;φ(0)，即f(xk+αkdk)\u0026lt;f(xk) 这就是线性搜索\n3.1.2精确线性搜索   目标函数沿搜索方向dk达到极小值，即使得 f(xk+αkdk)=min f(xk+αkdk)\n  或选取αk\u0026gt;0使得到达最低点（各方向导数为0）移动的步长最短的搜索方法 αk=min{α\u0026gt;0|▽f(xk+αkdk)Tdk=0} （一维到多维的扩充-\u0026gt;在这点到某一方向的极小距离内的全微分，▽就是全微分）\n  对于αk=min{α\u0026gt;0|▽f(xk+αkdk)Tdk=0}（到达极小点步长最短） ∵xk+1=xk+αkdk∴原式为 ▽f(xk+1)T. dk且：gk= ▽ f(xk) ≠ 0 （xk在f(x)的偏导） 故：= gk+1T. dk线性搜索要求：下一梯度与当前下降方向垂直\n  3.1.3 线性搜索研究大纲 按步骤分为两部分：1. 确定包含最优解的初始区间 2. 通过分割和插值缩小区间。直到|b-a|\u0026lt;ε\n  确定初始区间：进退法/加步探索法 基本思想：试图确定函数呈现“高-低-高”的三点 具体步骤：\n 给出初始点α0\u0026gt;0,初始步长h0\u0026gt;0 若φ(α0+h0)\u0026lt;=φ(α0) 则下一步从α1=α0+h0出发，且h1=2h0，直到上升为止 若φ(α0+h0)\u0026gt;=φ(α0),则沿反方向搜索，直到目标函数上升 也可以取导数，步长加倍来算    缩小区间的方法，根据是否利用导数信息分为两种\n 无导数法：二分法、黄金分割法（0.618法）、斐波那契法（Fibonacci） 有导数法：插值法（一般比无导数法更有效） 不精确线性搜索方法    3.2.1 0.618法 在a-b的区间中选取两个对称点，比较其函数值，左侧\n选取根号五减一除以二的近似值：0.618\n3.2.2 Fibonacci法 3.2.3 二分法 四、无约束最优化方法 没有约束条件（初始区间），所以需要确定的是下降方向和下降步长。\n最速下降法——最基本的方法\n牛顿法——最主要的方法\n共轭梯度法——解大型优化问题的首选\n拟牛顿法，尤其是BFGS——是目前最成功的方法\n4.1最速下降/梯度法 梯度：就是表示某一函数在该点处的方向导数沿着该方向取得最大值，即函数在当前位置的导数。其实质是迭代点的一次Taylor展开。（在迭代点处用一阶Taylor逼近目标函数，那这个Taylor的最速下降方向不就是原函数的下降方向吗？）\n∇=df(θ)dθ有正有负\n下降方向：负梯度方向 推导过程：\ngk= ▽ f(xk) ≠ 0 （xk在f(x)的偏导） f(x)在xk处的Taylor展开 f(x)=f(xk) + g k T(x-xk) + o(||x-xk||) 令：x=xk+αdk（α：步长是常数，dk：下降方向——构造线性搜索条件） ∴f(xk+αdk) = f(xk)+ g k T(αdk) + o(||αdk||) 即：φ(α)=φ(0) + g k T(αdk)\n可以看出（步长大于0）当g k Tdk\u0026lt;0 时 dk为下降方向，即：|g k T|.|dk|cosθ\u0026lt;0，几何意义为运行方向和梯度的夹角大于90°，α取定后显然夹角约接近于180°下降的越快，即dk= -gk\n将dk= -gk代回，得到： xk+1=xk-αgk（下一个位置 =上一个位置 + 步长x下降方向）\n移动步长：线性搜索确定 求正定二次函数的步长：\nf(x)=1/2 x TQ x +b Tx + c 取x=xt，▽f(xt)=gt=Qxt+b dt=-gt=-Qxt-b αt使得f(xk+αkdk)=min f(xk+αkdk) f(xt+1)=f(xt+ αtdt) =f(xt- gtαt)=argmin(1/2 gtT Q gtαt2- gtT gtαt+f(xt)) 运用-b/2a = αt= **gtT gt/gtT Q gt** ∴迭代公式为：**xt+1=xt-(gtT gt/gtT Q gt)**gt具体计算时 可以先设置下降方向为负梯度方向，代入f(xt+1)的式子中，得到关于αt的函数，令该函数为0，得到最优步长。 例题： 性质   优点：计算工作量小，存储量小，对初始点无要求\n  缺点：局部最速，整体求解缓慢（等值线为扁长椭球时开始较快，后来出现锯齿现象） 对于αk=min{α\u0026gt;0|▽f(xk+αkdk)Tdk=0}（到达极小点步长最短） ∵xk+1=xk+αkdk∴原式左侧为 ▽f(xk+1)T. dk且：gk= ▽ f(xk) ≠ 0 （xk在f(x)的偏导） 故 gk+1T. dk= 0 线性搜索要求：下一梯度与当前下降方向垂直 且下降方向是负梯度方向(最速下降法要求的dk= -gk+1T) ∴ gk+1T. gk=dk+1T. dk= 0 (相邻梯度方向垂直、相邻下降方向垂直) 所以后来会出现锯齿现象。\n  4.2 牛顿法 https://zhuanlan.zhihu.com/p/293951317\n4.2.1 牛顿法基操 基本思想：在迭代点处对目标函数进行二次Taylor后，用二阶Taylor极小点去逼近目标极小点（最速下降法用一阶Taylor不行，那我二阶的试试？）\n推导过程 在xk附近展开（要求二次连续可微） f(xk+s) = f(xk)+ ▽f(xk) Ts + 1/2 sT▽2f(xk)s + o(||αdk||) 对s求导令其为0得：▽f(xk) + ▽2f(xk)s = 0 （要求Hesse（▽2f(xk)）正定） ∴ s = (▽2f(xk))-1. -▽f(xk) xk+1=xk+s=xk+(▽2f(xk))-1. -▽f(xk) =xk -（f(xk)一阶梯度/f(xk)二阶梯度）\n与最速下降法对比 不需要求方向，步长，直接s一步到位，因为二阶中有 sT▽2f(xk)s，对s求导后还有一个s，可以直接表示出s。而一阶的最速下降法，因为对s求导后，是常数了，所以不可以这么做。性质  对于正定二次函数f(x)=1/2 x TAx+b T x+c，牛顿法可以一步到位 一般非二次函数，不能保证迭代得到最优解 若初始点充分靠近极小点，牛顿法收敛的速度一般是快的，且具有二阶收敛速度 这个方法要求迭代点处二次连续可微+Hesse可逆 而且需要计算Hesse的逆矩阵，存储和计算都很麻烦。  4.2.2带步长因子的牛顿法/阻尼牛顿法 初始点远离最优解时，Hesse 不一定正定，无法保证收敛性，所以在前面加入αk步长因子，通过线性搜索得到步长因子。\nxk+1= xk+ αk(▽2f(xk))-1. -▽f(xk) αk\u0026gt;=0, 使得xk+ αk(▽2f(xk))-1. -▽f(xk)最小 同最速下降法一样，令其为0，解得αk带步长因子的牛顿法是总体收敛的\n4.3 共轭梯度 FR共轭梯度法实际上是利用梯度和上一次的搜索方向来构造本次搜索方向：\ndk=-gk+βk-1dk-1 即：用上一次的搜索方向修正最速下降法的负梯度方向，不仅避免了锯齿现象，与牛顿法相比也节约了计算量。运用共轭，线性无关的同时，也适应大条件数。\n共轭梯度法克服了最速下降法收敛慢，只需要利用一阶导数信息，避免了牛顿法存储和计算hesse矩阵的空间 对大型线性或非线性方程组都非常有效\n共轭 首先，什么是共轭\n设 d1,d2\u0026hellip; dm是Rn中任意一组非零向量，若 diTG di= 0 ( i ≠ j ) 则称d1,d2\u0026hellip; dm是 G-共轭的。显然 d1,d2\u0026hellip; dm线性无关，若G = I， 则是正交关系。\n推导 matlab 代码实现：\n4.4 拟牛顿 牛顿法的关键就是利用了Hesse的曲率信息，但是Hesse的计算和存储都很困难，那可否用梯度和目标函数这些信息来构造曲率近似呢？\n实际上就是用Bk代替牛顿法中的Hesse矩阵，Hk替牛顿法中的Hesse逆矩阵\n    牛顿法 拟牛顿法     迭代公式 xk+1= xk - αk(▽2f(xk))-1▽f(xk)) xk+1= xk- αkBk-1. ▽f(xk)   dk搜索方向 - (▽2f(xk))-1▽f(xk)) - Bk-1. ▽f(xk)    所以就是搜索方向用 - Bk-1. ▽f(xk) 迭代， 初始时Bk为单位矩阵，搜索方向为最速方向\n性质  仅需一阶导数 Bk正定 即可使该方法有下降性质 搜索方向互相共轭  Hk更新 xk+1= xk- αkBk-1. gksk= xk+1- xk，yk= gk+1- gk那么如何更新Hesse逆的近似——Hk呢？我们提出了两种修正方法。\nDFP校正 BFGS校正 两次运用秩一校正得到关于Bk的迭代公式\n五、小二乘 六、二次规划 非线性约束优化问题\n研究带有二次目标函数和线性约束的最优化问题\n二次规划(QP)问题下，若Hesse为正定，则为凸规划问题\n前m个为不等式约束，后l个是等式约束\n6.2 等式约束二次规划问题 min 1/2 xTQ x + cT x s. t. Ax=b 假设\n Q为半正定，则为凸问题 A mXn, r(A)=m, A行满秩  直接消去法 联想：\nAx=b线性方程组求解\n对A分块=（B，N）\n对应x分块 $$ x=\\left( \\begin{matrix} x_B \\\nx_N \\end{matrix} \\right) $$ BxB+NxN=b xB=B-1b-B-1NxN$$ x=\\left( \\begin{matrix} x_B \\\nx_N \\end{matrix} \\right)=\\left( \\begin{matrix} B^{-1}b-B^{-1}Nx_N \\\nx_N \\end{matrix} \\right)\\=\\left( \\begin{matrix} B^{-1}b \\\n0 \\end{matrix} \\right)+\\left( \\begin{matrix} -B^{-1}N \\\nE_{n-m} \\end{matrix} \\right)x_N\\tag{1} $$\n式1 最后一行，记第一个是x0，是特解，第二个括号内的记为Z，是导出组的基础解系\nx=x0+ZxNx0为已知的特解，所以原问题可以转化为关于xN的无约束优化问题\nKKT方法 广义消去法\nLagrange 法\nhttps://www.zhihu.com/question/38586401\n6.3 有效集方法（解不等式约束） 七、约束最优化的理论与方法 7.2二次罚函数法 附录 希腊字母表 ","permalink":"https://dp.ckvb.run/post/bestbefit/","summary":"三、线性搜索 3.1什么是线性搜索？ 3.1.1线性搜索的概念 xk+1=xk+αkdkαk：步长因子 dk：搜索方向 则下一步的位置设为φ(α)=f(xk+αkdk)\n从xk出发沿dk方向搜索，确定步长因子αk使得φ(α)\u0026lt;φ(0)，即f(xk+αkdk)\u0026lt;f(xk) 这就是线性搜索\n3.1.2精确线性搜索   目标函数沿搜索方向dk达到极小值，即使得 f(xk+αkdk)=min f(xk+αkdk)\n  或选取αk\u0026gt;0使得到达最低点（各方向导数为0）移动的步长最短的搜索方法 αk=min{α\u0026gt;0|▽f(xk+αkdk)Tdk=0} （一维到多维的扩充-\u0026gt;在这点到某一方向的极小距离内的全微分，▽就是全微分）\n  对于αk=min{α\u0026gt;0|▽f(xk+αkdk)Tdk=0}（到达极小点步长最短） ∵xk+1=xk+αkdk∴原式为 ▽f(xk+1)T. dk且：gk= ▽ f(xk) ≠ 0 （xk在f(x)的偏导） 故：= gk+1T. dk线性搜索要求：下一梯度与当前下降方向垂直\n  3.1.3 线性搜索研究大纲 按步骤分为两部分：1. 确定包含最优解的初始区间 2. 通过分割和插值缩小区间。直到|b-a|\u0026lt;ε\n  确定初始区间：进退法/加步探索法 基本思想：试图确定函数呈现“高-低-高”的三点 具体步骤：\n 给出初始点α0\u0026gt;0,初始步长h0\u0026gt;0 若φ(α0+h0)\u0026lt;=φ(α0) 则下一步从α1=α0+h0出发，且h1=2h0，直到上升为止 若φ(α0+h0)\u0026gt;=φ(α0),则沿反方向搜索，直到目标函数上升 也可以取导数，步长加倍来算    缩小区间的方法，根据是否利用导数信息分为两种\n 无导数法：二分法、黄金分割法（0.618法）、斐波那契法（Fibonacci） 有导数法：插值法（一般比无导数法更有效） 不精确线性搜索方法    3.2.1 0.618法 在a-b的区间中选取两个对称点，比较其函数值，左侧\n选取根号五减一除以二的近似值：0.618\n3.2.2 Fibonacci法 3.2.3 二分法 四、无约束最优化方法 没有约束条件（初始区间），所以需要确定的是下降方向和下降步长。","title":"Bestbefit"},{"content":"tesdsdad a sdasd asd\n","permalink":"https://dp.ckvb.run/post/test/","summary":"tesdsdad a sdasd asd","title":"Test"},{"content":"K3s with clilium and loki Install k3s and disable default CNI curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\u0026#39;--flannel-backend=none --disable-network-policy\u0026#39; sh - then you can add agent nodes also,you can find node-token at /var/lib/rancher/k3s/server/node-token,and install k3s agent nodes with follow commend.\ncurl -sfL https://get.k3s.io | K3S_URL=\u0026#39;https://${MASTER_IP}:6443\u0026#39; K3S_TOKEN=${NODE_TOKEN} sh - Install the Cilium with the Cilium CLI curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz{,.sha256sum} sha256sum --check cilium-linux-amd64.tar.gz.sha256sum sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin rm cilium-linux-amd64.tar.gz{,.sha256sum} Install Cilium by running:\ncilium install # install hubble  cilium hubble enable --ui Running the following command to check out:\ncilium status cilium connectivity test Install loki with grafana and prometheus by helm helm upgrade --install loki --namespace=\u0026lt;YOUR-NAMESPACE\u0026gt; grafana/loki-stack --set grafana.enabled=true,prometheus.enabled=true,prometheus.alertmanager.persistentVolume.enabled=false,prometheus.server.persistentVolume.enabled=false Get the passwd of grafana\nkubectl get secret --namespace \u0026lt;YOUR-NAMESPACE\u0026gt; loki-grafana -o jsonpath=\u0026#34;{.data.admin-password}\u0026#34; | base64 --decode ; echo ","permalink":"https://dp.ckvb.run/post/k3s/","summary":"K3s with clilium and loki Install k3s and disable default CNI curl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\u0026#39;--flannel-backend=none --disable-network-policy\u0026#39; sh - then you can add agent nodes also,you can find node-token at /var/lib/rancher/k3s/server/node-token,and install k3s agent nodes with follow commend.\ncurl -sfL https://get.k3s.io | K3S_URL=\u0026#39;https://${MASTER_IP}:6443\u0026#39; K3S_TOKEN=${NODE_TOKEN} sh - Install the Cilium with the Cilium CLI curl -L --remote-name-all https://github.com/cilium/cilium-cli/releases/latest/download/cilium-linux-amd64.tar.gz{,.sha256sum} sha256sum --check cilium-linux-amd64.tar.gz.sha256sum sudo tar xzvfC cilium-linux-amd64.tar.gz /usr/local/bin rm cilium-linux-amd64.tar.gz{,.sha256sum} Install Cilium by running:","title":"K3s on the cloud"},{"content":"Flink in Native Kubernetes deploy flink in the Session Mode flink will deploy in the namespace default as default and use default as serviceaccount, if we want deploy in another namespace, we can set kubernetes.namespace. and we should modify the serviceacount.We either modify the permissions of default or create a new serviceAccount.\ncreate serviceaccount flink-service-account $ kubectl create serviceaccount flink-service-account $ kubectl create clusterrolebinding flink-role-binding-flink --clusterrole=edit --serviceaccount=default:flink-service-account delpoy the flink ./bin/kubernetes-session.sh -Dkubernetes.cluster-id=first\\  -Dkubernetes.service-account=flink-service-account \\  -Dtaskmanager.memory.process.size=4096m \\  -Dtaskmanager.numberOfTaskSlots=2 \\  -Dresourcemanager.taskmanager-timeout=3600000 flink will create taskmanger when a job was submitted, resources will be requested before taskmanger starts, and the usage of cpu is set to the number of slots per TaskManager by default. before submit we need to make sure that we can reach the jobmanger. we can set service in the type of NodePort\nsubmit the job ./bin/flink run -d -e kubernetes-session -Dkubernetes.cluster-id=first examples/streaming/WindowJoin.jar relate config\nNative Kubernetes\n","permalink":"https://dp.ckvb.run/post/fuck/","summary":"Flink in Native Kubernetes deploy flink in the Session Mode flink will deploy in the namespace default as default and use default as serviceaccount, if we want deploy in another namespace, we can set kubernetes.namespace. and we should modify the serviceacount.We either modify the permissions of default or create a new serviceAccount.\ncreate serviceaccount flink-service-account $ kubectl create serviceaccount flink-service-account $ kubectl create clusterrolebinding flink-role-binding-flink --clusterrole=edit --serviceaccount=default:flink-service-account delpoy the flink .","title":"flink"}]